# Materia and Docker

Materia is deployed in docker containers orchestrated through docker compose in both development and production environments.

## Overview

### Container Architecture

 1. [webserver (Nginx)](https://www.nginx.com/) runs the NGINX web server (proxies to phpfpm for app and serves static files directly).
 2. [app (PHP-FPM)](https://php-fpm.org/) runs and manages the PHP processes for the application.
 3. [mysql](https://www.mysql.com/) for storing relational application data. _We recommend an external database source in production_.
 4. [memcached](https://memcached.org/) for caching data and sessions.
 5. [fakeS3](https://github.com/jubos/fake-s3) mocks AWS S3 behavior for asset uploading. _This should not be used in production._

### Docker Compose files

The default `docker-compose.yml` file contains some base-level configurations for Materia:

- The `app` service definition and its associated image.
- The `webserver` service definition and its associated image.
- The `frontend` and `backend` docker networks.

The `docker-compose.override.yml` file is not tracked and generated by either the `run_first_for_dev.sh` or `run_first_for_nondev.sh` scripts. By default, `docker compose up` will initialize with both the `docker-compose.yml` and `docker-compose.override.yml` (if present) configurations. Docker compose can always be run with a different set of compose files via the `-f` flag:

```
docker compose -f docker-compose.yml -f docker-compose.my-override.yml up
```

### Volumes

Docker volumes are used to mount files from the host machine into one or more containers, and to share file contents between containers. Depending on whether you are pursuing a development or more prod-like instance, the individual volume definitions will be different.

- **Development**: Your entire project directory is mounted to the `app` container. Static assets and widget assets are cross-mounted to the `webserver` container.
- **Production**: Static (compiled) assets are virtually mounted on the `app` container and cross-mounted on the `webserver` container. Widget engine files and user media files (if using the `file` asset storage driver) are volume mounted from the host machine.

### Data Persistence

Because docker containers are relatively ephemeral, it is recommended that certain resources and configurations are saved on the host machine or an external service and synced with the containers after they are running. This is especially important to facilitate future updates to the system. Let's review each:

#### The database

We highly recommend using an external database service like Amazon RDS, Azure Database for MySQL, or Cloud SQL. While the development instance of Materia uses a local MySQL database, this is not recommended for production. Regardless of where your database is located, you should perform regular backups.

#### Configuration files, like env variables

These configuration files should be defined on the host machine or an external service like AWS Secrets Manager. The docker compose file can define individual environment variables or import a local `.env` or `.env.local` file. Materia ships with a `.env` file (and `.env.local`) for local development.

#### Installed widget files

Widget files are installed to `/var/www/html/public/widget` on the application container, which is volume mounted from the host machine (in the Materia project directory: `public/widget`) and cross-mounted to the webserver container. These should be synced with an external service like AWS S3 or an external filesystem on a semi-regular interval.

#### User uploaded media

User media storage will depend on your `ASSET_STORAGE_DRIVER` configuration. If the `file` storage driver is in use, user media is saved to `/var/www/html/fuel/app/media` on the application container by default, custom configuration changes notwithstanding. Like installed widget files, this directory is volume mounted from the home machine (in the Materia project directory: `fuel/app/media`) and should be synced on a frequent interval with an external service like AWS S3.

## Setup Details

### Setup: Development Environment

Use `./run_first_for_dev.sh` in the `docker/` directory to initialize the application for development. Environment configurations specific to development include:

1. Use of `memcached` for cache and session storage
2. Use of `fakes3` for asset storage
3. Use of a local `mysql` database on a dedicated `mysql` container
4. Volume mounting the entire project directory into the application container, so that modifications of server files on the host machine are reflected in the running application
5. Configuration of an additional port (`8008`) to simulate serving static assets from a second domain

### Setup: Non-Development Environment

The non-dev configuration is ideal for those looking to play around with Materia locally without doing any local development. Additionally, it serves as a reasonal starting point for standing up a production instance of Materia.

The nondev startup script walks you through a series of configuration decisions to dynamically write the `docker-compose.override.yml` file. These include:

1. The IP you use to access docker on your host machine (usually `localhost`)
2. The use of a local database in a dedicated `mysql` container
3. The cache driver configuration (`memcached` or `file`)
4. The session driver configuration (`memcached`, `file`, or `db`)
5. The asset storage driver configuration (`file` or `db`)

Additionally, the script will explicitly ask whether or not you want to install the default set of widgets. While this is required for fresh instances, if using an existing database, this may not be desired.

### Environment Configuration

The `docker/` directory contains two `env` files:

1. `.env` contains default dev-specific default values. This file is tracked, and changes to it are not generally recommended
2. `.env.local` is created by either of the `run_first` scripts. It contains environment configuration overrides and should be considered the authoritative source for environment variables.

If a different `env` file is desired, make sure to update your `docker-compose.override.yml` file with changes to the `env_file` parameter in the `app` service definition.

The Materia application will defer to environment variables to populate many configuration options. Storing these in environment variables that are loaded via docker compose ensure configurations will persist across container instances.

For a full breakdown of the environment variables available, refer to the [Server Variables](https://ucfopen.github.io/Materia-Docs/admin/server-variables.html) page in the documentation.

### Image Versioning

Both the dev and nondev scripts use the `-dev` versions of the `app` and `webserver` images. These are automatically built and deployed to the [GitHub package registry](https://github.com/ucfopen/Materia/pkgs/container/materia) for _any_ version tag, including `alpha` and `rc` tags. For convenience, a number of different image tags are provided: `-dev`, `-stable`,  `-<version>`, and `-<commit hash>`.

`-stable` images are only created for stable releases (`v10.3.0` as opposed to `v10.3.0-alpha.1`).

In a production instance, we recommend locking images to a specific version in your `docker-compose.override.yml`:

```
services:
  app:
    image: ghcr.io/ucfopen/materia:app-v10.3.0
```

By default, the base `docker-compose.yml` file will contain the `image` definitions for the `app` and `webserver` services. These can be overridden in the override compose file or applied to a standalone compose file depending on your preferred compose configuration.

### Database Migrations

Updating to a new version of Materia may require migrations to be performed on the database. These are handled by the built-in migration utility in FuelPHP. Database migration state is stored in the database in `migration` table.

> [!IMPORTANT]
> As with all database modifications, you should ensure a backup is performed prior to running a migration.

In `docker/`:
```
./run.sh php oil r migrate
```

## Commands and Utilities

### Common Dev Commands

* Run commands on the app container (like php, composer, or fuelphp oil commands)
    ```
    ./run.sh php -i
    ./run.sh php oil r admin:help
    ./run.sh composer run --list
    ```

* Stop containers (db data is retained)
    ```
    docker compose stop
    ```
* Stop and destroy the containers (deletes database data!, first_run.sh required after)
    ```
    docker compose down
    ```
* Install composer libraries on the app container
    ```
    ./run.sh composer install
    ```
* Install all Widgets in fuel/app/tmp/widget_packages/*.wigt
    ```
    ./run_widgets_install.sh '*.wigt'
    ```
* Run Tests for development
     ```
    ./run_tests.sh
    ```
* Run Tests with code coverage
     ```
    ./run_tests_coverage.sh
    ```
* Create a user based on your docker host machine's current user
     ```
    $ max_power@ucf: ./run_create_me.sh
    User Created: max_power password: kogneato
    max_power now in role: super_user
    max_power now in role: basic_author
    ```
* Create a user manually
	```
	./run.sh php oil r admin:new_user username firstname mi lastname email password
	```
* Installing widgets: Copy the widget file you want to install into **app/fuel/app/tmp/widget\_packages/** and then run **install_widget.sh** passing the name of the widget file to install. Example:

    ```
    cp my_widget.wigt ~/my_projects/materia_docker/app/fuel/app/tmp
    cd ~/my_projects/materia_docker
    ./run_widgets_install.sh my_widget.wigt
    ```

### Default User Accounts

If you wish to log into Materia, there are [3 default accounts created for you based on the config](https://github.com/ucfopen/Materia/blob/master/fuel/app/config/materia.php#L56-L78). If you're on OSX or Linux, you'll also get a user based on the username you use on the host machine.

### Updating a container

If you're wanting to update a php or mysql version, this can be done locally for testing before updating the global image.

1. finish your edits.
2. Execute `docker compose build` to rebuild any images.
4. Removing any existing running container using that image: `docker compose stop app` and `docker compose rm app`
5. Start the desired container: `docker compose up app`
